### 常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的
* 数据库缓存
    * Query Cache,以SQL作为key值缓存查询结果集
    * Data Buffer,data buffer是数据库数据在内存中的容器
* 应用程序缓存
    * 对象缓存，由ORM对象关系映射框架如Hibernate提供，透明性访问，细颗粒度缓存数据库查询结果，无需业务代码显式编程，是最省事的缓存策略
    * 查询缓存对数据库查询结果集进行缓存，类似数据库的Query Cache
    * 页面缓存，动态页面静态化、Servlet缓存、页面内部缓存
* Web服务器端缓存，基于代理服务器模式的Web服务器端缓存，如squid/nginx
* 基于ajax的浏览器缓存，使用AJAX调用的时候，将数据库在浏览器端缓存
***
### 用java自己实现一个LRU

### 分布式集群下如何做到唯一序列号
* 最常见的方式，利用数据库，全数据库唯一
* UUID，常见的方式，可以利用数据库也可以利用程序生成
* zookeeper主要通过其znode数据版本来生成序列号，可以生成32位和64位的数据版本号
* Redis生成，mongodb的objectId
***
### 设计一个秒杀系统，30 分钟没付款就自动关闭交易
* 限流:仅让能成功抢购到商品的流量进入我们的系统
* 削峰:将进入系统的瞬时高流量拉平，使得系统可以在自己处理能力范围内，将所有抢购的请求处理完毕
* 异步:请求不是被立刻处理的，因此就要求我们能将同步的服务改造成异步的
* 可用性、用户体验、容错处理(超时重试)
* 30分钟关闭,可以借助redis的发布订阅机制,在失效时进行后续操作，其他mq也可以
* 发布者和订阅者都是Redis客户端，Channel则为Redis服务器端，发布者将消息发送到某个的频道，订阅了这个频道的订阅者就能接收到这条消息,Redis的这种发布订阅机制与基于主题的发布订阅类似，Channel相当于主题
*** 
### 分布式锁，如何使用redis和zookeeper实现分布式锁？有什么区别优缺点，分别适用什么场景
* 基于数据库(表记录)实现分布式锁,直接创建一张锁表，然后通过操作该表中的数据来实现,但数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用
* 基于缓存(redis、memcached)实现分布式锁,集群部署，可以解决单点问题，支持数据的过期自动删除，可以直接设置超时时间来控制锁的释放，实现分布式锁的方法，比如Tair的put方法，redis的setnx方法
* 基于zookeeper实现分布式锁，客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点，判断是否获取锁的方式很简单，只需要判断有序节点是否是序号中最小的一个，当释放锁的时候，只需将这个瞬时节点删除即可，性能上不如缓存，但可靠性很高，有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题
***
### 如果有人恶意创建非法连接，怎么解决
* 使用Servlet中的过滤器技术处理，对如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能，实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能
***
### 分布式事务的原理，优缺点，如何使用分布式事务
* CAP：WEB服务无法同时满足一致性、可用性和分区容错性
* BASE：基本可用，软状态和最终一致性
* 基于XA协议的两阶段提交
    * 第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交
    * 第二阶段：事务协调器要求每个数据库提交数据
* 补偿事务(TCC)，针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作
* 消息事务+最终一致性，基于消息中间件的两阶段提交，将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功并且对外发消息成功，要么两者都失败
*** 
### 一致性hash
* 判断hash算法好坏的四个定义
    * 平衡性：哈希的结果能够尽可能分布到所有的缓冲中
    * 单调性：新节点加入时，保证原来内容还是能够映射到原来相应的节点上
    * 分散问题：同样的内容可能被映射到不同的机器缓存中
    * 负载问题：一个缓存节点可能被不同用户映射为不同的内容，造成节点的负载加重
* 将数据或对象或机器通过一定的hash算法处理后映射到环上，以顺时针方向计算，将所有对象存储到离自己最近的机器中
***
### 什么是restful，讲讲你理解的restful
* REST指的是一组架构约束条件和原则，满足这些约束条件和原则的应用程序或设计就是RESTful
***
### 如何设计建立和保持100w的长连接
* 服务器内核调优(tcp，文件数)，客户端调优，框架选择(netty)
***
### 如何防止缓存雪崩
* 缓存雪崩可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机
解决思路： 
* 采用加锁计数，或者使用合理的队列数量来避免缓存失效时对数据库造成太大的压力,这种办法虽然能缓解数据库的压力，但是同时又降低了系统的吞吐量
* 分析用户行为，尽量让失效时间点均匀分布,避免缓存雪崩的出现 
* 如果是因为某台缓存服务器宕机，可以考虑做主备，比如：redis主备，但是双缓存涉及到更新事务的问题，update可能读到脏数据，需要好好解决
*** 
### 解释什么是MESI协议(缓存一致性)
* I，失效缓存段(Invalid)，要么已经不在缓存中，要么它的内容已经过时
* S，共享缓存段(Shared)，与主内存内容保持一致，只能被读取，不能被写入，多组缓存可以同时拥有针对同一内存地址的共享缓存段
* E，独占缓存段(Exclusiv),与主内存内容保持一致，如果一个处理器持有了某个E状态的缓存段，那其他处理器就不能同时持有它
* M，已修改缓存段(Modified)，属于脏段，已经被所属的处理器修改了，在其他处理器缓存中的拷贝马上会变成失效状态，在已修改缓存段被丢弃或标记为失效前，需要把它的内容回写到内存中
*** 
### 说说你知道的几种HASH算法，简单的也可以
* 加法Hash，位运算Hash,乘法Hash，除法Hash，查表Hash，混合Hash
***
### 什么是paxos算法
* 是分布式一致性算法用来解决一个分布式系统如何就某个值(决议)达成一致的问题
* 基于消息传递的一致性算法，prepare阶段和acceptor阶段
***
### 一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新
* 点击编辑的时候，利用redis进行加锁setNX完了之后expire一下，也可以用版本号进行控制
***
### 线上系统突然变得异常缓慢，你如何查找问题
* 逐级排查（网络，磁盘，内存，cpu），数据库，日志，中间件等也可通过监控工具排查
***
### 说说你平时用到的设计模式
* 单例：保证一个类仅有一个实例,并提供一个访问它的全局控制点
* 代理：
* 模板
* 策略
* 命令
***
### Dubbo的原理，数据怎么流转的
* client线程生成一个唯一的ID，Dubbo是使用AtomicLong从0开始累计数字的，打包接口名，方法名，参数值列表和处理结果的回调对象callback，封装在一起组成一个对象object
* 向专门存放调用信息的全局ConcurrentHashMap里面put(ID, object)，将ID和打包的方法调用信息封装成一对象connRequest，使用IoSession.write(connRequest)异步发送出去
* 当前线程使用callback的get()方法试图获取远程返回的结果，在get()内部使用synchronized获取回调对象callback的锁， 先检测是否已经获取到结果，如果没有调用callback的wait()方法，释放callback上的锁，让当前线程处于等待状态
* 服务端接收到请求并处理后，将结果发送给客户端，客户端socket连接上专门监听消息的线程收到消息，分析结果取到ID，再从前面的ConcurrentHashMap里面get(ID)，从而找到callback，将方法调用结果设置到callback对象里
* 监听线程接着使用synchronized获取回调对象callback的锁（因为前面调用过wait()，那个线程已释放callback的锁了），再notifyAll()，唤醒前面处于等待状态的线程继续执行（callback的get()方法继续执行就能拿到调用结果了），至此，整个过程结束
*** 
### 一次RPC请求的流程是什么
* 服务消费方（client）调用以本地调用方式调用服务
* client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体
* client stub找到服务地址，并将消息发送到服务端 
* server stub收到消息后进行解码
* server stub根据解码结果调用本地的服务
* 本地服务执行并将结果返回给server stub 
* server stub将返回结果打包成消息并发送至消费 
* client stub接收到消息，并进行解码 
* 服务消费方得到最终结果
***
### 异步模式的用途和意义
* 异步模式使用于服务器多核，并发严重的场景 可提高服务吞吐量大，不容易受到冲击，可以采用并发策略，提高响应时间 
***
### 缓存数据过期后的更新如何设计
* 失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中
* 命中：应用程序从cache中取数据，取到后返回 
* 更新：先把数据存到数据库中，成功后，再让缓存失效
***
### 如何实现负载均衡
* 将大量的并发请求分担到多个处理节点，由于单个处理节点的故障不影响整个服务，负载均衡集群同时也实现了高可用性
* 常见的有：
    * DNS域名解析负载均衡，域名解析时经过DNS服务器的算法将一个域名请求分配到合适的真实服务器上
    * 反向代理负载均衡，根据负载均衡算法将请求的浏览器访问转发到不同的web服务器处理，处理结果经过反向服务器返回给浏览器
    * IP负载均衡：通过修改目标地址进行负载均衡
### 后台系统怎么防止请求重复提交
* 可以通过token值进行防止重复提交，存放到redis中，在表单初始化的时候隐藏在表单中，添加的时候在移除，判断这个状态即可防止重复提交
***
### Mybatis底层实现原理
* 支持定制化SQL、存储过程以及高级映射的优秀的持久层框架，封装JDBC操作，利用反射打通Java类与SQL语句之间的相互转换
***
### zookeeper
* 做的事情：命名服务，配置管理，集群管理，分布式协调通知

