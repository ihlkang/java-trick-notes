### 常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的
* 数据库缓存
    * Query Cache,以SQL作为key值缓存查询结果集
    * Data Buffer,data buffer是数据库数据在内存中的容器
* 应用程序缓存
    * 对象缓存，由ORM对象关系映射框架如Hibernate提供，透明性访问，细颗粒度缓存数据库查询结果，无需业务代码显式编程，是最省事的缓存策略
    * 查询缓存对数据库查询结果集进行缓存，类似数据库的Query Cache
    * 页面缓存，动态页面静态化、Servlet缓存、页面内部缓存
* Web服务器端缓存，基于代理服务器模式的Web服务器端缓存，如squid/nginx
* 基于ajax的浏览器缓存，使用AJAX调用的时候，将数据库在浏览器端缓存
***
### 用java自己实现一个LRU

### 分布式集群下如何做到唯一序列号
* 最常见的方式，利用数据库，全数据库唯一
* UUID，常见的方式，可以利用数据库也可以利用程序生成
* zookeeper主要通过其znode数据版本来生成序列号，可以生成32位和64位的数据版本号
* Redis生成，mongodb的objectId
***
### 设计一个秒杀系统，30 分钟没付款就自动关闭交易
* 限流:仅让能成功抢购到商品的流量进入我们的系统
* 削峰:将进入系统的瞬时高流量拉平，使得系统可以在自己处理能力范围内，将所有抢购的请求处理完毕
* 异步:请求不是被立刻处理的，因此就要求我们能将同步的服务改造成异步的
* 可用性、用户体验、容错处理(超时重试)
* 30分钟关闭,可以借助redis的发布订阅机制,在失效时进行后续操作，其他mq也可以
* 发布者和订阅者都是Redis客户端，Channel则为Redis服务器端，发布者将消息发送到某个的频道，订阅了这个频道的订阅者就能接收到这条消息,Redis的这种发布订阅机制与基于主题的发布订阅类似，Channel相当于主题
*** 
### 分布式锁，如何使用redis和zookeeper实现分布式锁？有什么区别优缺点，分别适用什么场景
* 基于数据库(表记录)实现分布式锁,直接创建一张锁表，然后通过操作该表中的数据来实现,但数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用
* 基于缓存(redis、memcached)实现分布式锁,集群部署，可以解决单点问题，支持数据的过期自动删除，可以直接设置超时时间来控制锁的释放，实现分布式锁的方法，比如Tair的put方法，redis的setnx方法
* 基于zookeeper实现分布式锁，客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点，判断是否获取锁的方式很简单，只需要判断有序节点是否是序号中最小的一个，当释放锁的时候，只需将这个瞬时节点删除即可，性能上不如缓存，但可靠性很高，有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题
***
### 如果有人恶意创建非法连接，怎么解决
* 使用Servlet中的过滤器技术处理，对如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能，实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能
***
### 分布式事务的原理，优缺点，如何使用分布式事务
* CAP：WEB服务无法同时满足一致性、可用性和分区容错性
* BASE：基本可用，软状态和最终一致性
* 基于XA协议的两阶段提交
    * 第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交
    * 第二阶段：事务协调器要求每个数据库提交数据
* 补偿事务(TCC)，针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作
* 消息事务+最终一致性，基于消息中间件的两阶段提交，将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功并且对外发消息成功，要么两者都失败
*** 
### 一致性hash
* 判断hash算法好坏的四个定义
    * 平衡性：哈希的结果能够尽可能分布到所有的缓冲中
    * 单调性：新节点加入时，保证原来内容还是能够映射到原来相应的节点上
    * 分散问题：同样的内容可能被映射到不同的机器缓存中
    * 负载问题：一个缓存节点可能被不同用户映射为不同的内容，造成节点的负载加重
* 将数据或对象或机器通过一定的hash算法处理后映射到环上，以顺时针方向计算，将所有对象存储到离自己最近的机器中
***
### 什么是restful，讲讲你理解的restful
* REST指的是一组架构约束条件和原则，满足这些约束条件和原则的应用程序或设计就是RESTful
***
### 如何设计建立和保持100w的长连接
* 服务器内核调优(tcp，文件数)，客户端调优，框架选择(netty)
***
### 如何防止缓存雪崩
* 缓存雪崩可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机
解决思路： 
* 采用加锁计数，或者使用合理的队列数量来避免缓存失效时对数据库造成太大的压力,这种办法虽然能缓解数据库的压力，但是同时又降低了系统的吞吐量
* 分析用户行为，尽量让失效时间点均匀分布,避免缓存雪崩的出现 
* 如果是因为某台缓存服务器宕机，可以考虑做主备，比如：redis主备，但是双缓存涉及到更新事务的问题，update可能读到脏数据，需要好好解决
*** 
### 解释什么是MESI协议(缓存一致性)
* I，失效缓存段(Invalid)，要么已经不在缓存中，要么它的内容已经过时
* S，共享缓存段(Shared)，与主内存内容保持一致，只能被读取，不能被写入，多组缓存可以同时拥有针对同一内存地址的共享缓存段
* E，独占缓存段(Exclusiv),与主内存内容保持一致，如果一个处理器持有了某个E状态的缓存段，那其他处理器就不能同时持有它
* M，已修改缓存段(Modified)，属于脏段，已经被所属的处理器修改了，在其他处理器缓存中的拷贝马上会变成失效状态，在已修改缓存段被丢弃或标记为失效前，需要把它的内容回写到内存中
*** 
### 说说你知道的几种HASH算法，简单的也可以
* 加法Hash，位运算Hash,乘法Hash，除法Hash，查表Hash，混合Hash
***
### 什么是paxos算法
* 是分布式一致性算法用来解决一个分布式系统如何就某个值(决议)达成一致的问题
* prepare阶段：
    * 
* acceptor阶段