### 数据库隔离级别，含义，mysql默认的隔离级别是什么
* 事务的四大特性：原子性、一致性、隔离性、持久性
* 不考虑隔离性会发生：
    * 脏读：事务中多次的修改都还未提交，这时另一个并发的事务来访问该数据，会造成两个事务得到的数据不一致
    * 不可重复读：一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了
    * 幻读：事务T1对一个表中所有的行的某个数据做了修改，事务T2插入了一行新的数据，T1再查看刚刚修改的数据，会发现还有一行没有修改，就好像产生幻觉一样
* 四种隔离级别：
    * 串行化(避免脏读、不可重复读、幻读)
    * 可重复读(避免脏读、不可重复读)
    * 读已提交（避免脏读）
    * 读未提交（任何情况都无法保证）
    * 隔离级别最高的是串行化，但级别越高，效率越低，mysql默认的隔离级别是可重复读
***
### mysql储存引擎，各自优缺点
* MyIsam和InnoDB
    * MyISAM适合查询以及插入为主的应用，不支持事务，不支持外键
    * InnoDB支持事务，支持外键，适合频繁修改，支持行锁
    * 如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎
    * 如果你的应用程序对查询性能要求较高，就要使用MYISAM了
***
### 高并发下如何安全修改同一行数据
* 使用悲观锁，设定每次修改都会冲突，当前只有一个线程执行操作，结束后唤醒其他线程
***
### 乐观锁和悲观锁，InnoDB2种行级锁
* 乐观锁，总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现
* 悲观锁，总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起
* InnoDB行级锁：
    * 共享锁：又称读锁，若事务T对数据对象A加了S锁，则是事务T可以读A但不能修改A，其它事务只能再对他加S锁，而不能加X锁，直到T释放A上的S锁，这保证了其他事务可以读A，但在事务T释放S锁之前，不能对A做任何操作
    * 排它锁：又称写锁，若事务T对数据对象加X锁，事务T可以读A也可以修改A，其他事务不能对A加任何锁，直到T释放A上的锁,这保证了，其他事务在T释放A上的锁之前不能再读取和修改A
***
###  SQL的优化一般步骤是什么？
* 通过show status命令了解各种SQL的执行频率
* 定位执行效率较低的SQL语句
* 通过explain分析低效SQL的执行计划
* 确定问题并采取相应的优化措施
***
### 数据库会死锁？举一个死锁的例子，mysql如何解决死锁
* 会，如用户A访问表A(锁住了表A),然后又访问表B，另一个用户B 访问表B(锁住了表B)，然后企图访问表A，这时由于用户B已经锁住表B，用户A必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续,产生死锁
* 解决：仔细分析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进 行处理，尽量避免同时锁定两个资源
***
### Mysql的索引原理，索引类型有哪些，如何创建合理的索引，索引如何优化
* 索引的目的在于提高查询效率，B+树的数据结构，磁盘块-数据项
* 索引分为：普通索引、唯一索引、联合索引、全文索引、空间索引
* 索引类型：
    * hash类型的索引： 查询单条快，范围查询慢
    * btree类型的索引：b+树，层数越多，数据量指数级增长
* 创建索引时遵循的原则：
    * 索引的最左匹配特性，必须按照从左到右的顺序匹配
    * 尽量选择区分度高的列作为索引,主键的区分度为1，字段不重复的比例
    * 索引列不能参与计算，保持列干净
* 索引优化：
    * 在经常查询的表建立索引
    * 在大数据量检索中，尽量使用全文索引代替LIKE
    * 维护优化索引碎片，删除记录数据时，记录上的索引标记并未删除，这会产生数据垃圾会影响数据的检索效率
    * 避免使用聚合函数，尽量在检索条件后不使用聚合函数，这可能会使索引失效
***
### 聚集索引和非聚集索引的区别
* 聚集索引中键值的逻辑顺序决定了表中相应行的物理顺序，非聚集索引的逻辑顺序与磁盘上行的物理存储顺序不同
* 聚集索引的叶节点就是最终的数据节点，而非聚集索引的叶节仍然是索引节点，但它有一个指向最终数据的指针
* 正文内容本身就是一种按照一定规则排列的目录称为聚集索引
* 连续的“驰、张、弩”三字实际上是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射
***
### B+树和B树的区别
* B+树，只有叶子节点存储data，叶子节点包含了这棵树的所有键值，叶子节点不存储指针
* B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null
***
### B树怎么分裂的，什么时候分裂，为什么是平衡的
***
### MySQL中exists与in的使用
* exists()后面的子查询被称做相关子查询，他是不返回列表的值的，只是返回一个ture或false的结果
* in()后面的子查询，是返回结果集的，子查询先产生结果集,然后主查询再去结果集里去找符合要求的字段列表去.符合要求的输出,反之则不输出
* 如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in，反之如果主查询记录较少，子查询中的表大，又有索引时使用exists
***
### 数据库自增主键可能产生的问题
* 单表的情况下数据库自增id并没有什么问题，在一张表分布到多个数据库的情况下，使用表自增将会出现id重复的问题
* 解决方法：给每个数据库设置不同的开始id
* id列不设自增，由应用设置id
* 使用Redis分批次生成id，开始id为批次id x 每批次个数
***
