### 多线程的几种实现方式，什么是线程安全？
* 继承Thread类重写run方法，并通过调用.start()方法，启动线程
* 实现Runnable接口(Callable接口)重写run方法，Runnable接口的方式解决了Java单继承的局限，Runnable接口实现多线程比继承Thread类更加能描述数据共享的概念
* 如果所在的进程中有多个线程在同时运行，而这些线程可能会同时运行，如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，那么就是线程安全的
* 多线程的三个核心：原子性、可见性、顺序性
***
### volatile原理，作用，能代替锁？
* 原理：JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存
* 保存内存的可见性，所有线程都能看到共享内存的最新状态
* 防止指令重排：为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序
* 使用场景：1 对变量的写操作不依赖于当前值，2 该变量没有包含在具有其他变量的不变式中
* 不能代替锁，volatile不能保证原子性
* CAS: 三个参数(V,A,B)，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做
* CAS+volatile的非阻塞乐观锁的方式来降低同步锁带来的阻塞性能的问题,实现对共享变量的访问
***
### 线程的生命周期状态图
- ![](thread_live.png)
* 线程通过new方法创建，调用start()方法，线程进入就绪态，等待系统的调度（时间片轮转调度），当系统调度，进入运行状态，正常结束或者异常退出，进程进入死亡状态
* 处于运行状态的线程若遇到sleep()方法，则线程进入睡眠状态，不会让出资源锁，sleep()方法结束，线程转为就绪状态，等待系统重新调度
* 处于运行状态的线程可能在等待IO，也可能进入挂起状态，IO完成，转为就绪状态
* 处于运行状态的线程yield()方法，线程转为就绪状态（yield只让给权限比自己高的）
* 处于运行状态的线程遇到wait() 方法（object的方法），线程处于等待状态，需要notify()/notifyALL()来唤醒线程，唤醒后的线程处于锁定状态，获取了“同步锁”之后，线程才转为就绪状态
* 处于运行的线程加synchronized锁变成同步操作,处于锁定状态，获取了“同步锁”之后，线程才转为就绪状态
***
### sleep和wait的区别
* sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持，当指定的时间到了又会自动恢复运行状态，在调用sleep()方法的过程中，线程不会释放对象锁。
* 当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后，本线程才进入对象锁定池准备
***
### Lock和Synchronized的区别
* L是接口，S是关键字
* S是在JVM层面上实现的，可以监控S的锁定，并在代码执行时出现异常，JVM会自动释放锁定，L是通过代码实现的，要保证锁一定会被释放，就必须将unLock()放到finally{}中
* L可以当等待锁的线程响应中断，S不行，使用S时等待的线程会一直等待下去，不能响应中断
* L锁可以通过多种方法来尝试获取锁，S不可以
* L可以提高多个线程进行读写操作的效率
***
### Synchronized的原理是什么，解释：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁
* Java虚拟机中的同步（Synchronization）是基于进入和退出管程（Monitor）对象实现，无论是显式同步（有明确的monitorenter和monitorexit指令）还是隐式同步（依赖方法调用和返回指令实现的）都是如此
* 重排序：通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段，编译器重排序和运行期重排序，分别对应编译时和运行时环境
* 自旋锁：持有锁的线程能在很短时间内释放锁资源，那些等待竞争锁的线程就不需要进入阻塞挂起状态，它们只需要等一等(自旋)，等持有锁的线程释放锁后即可立即获取锁
* 偏向锁：Java6引入的一项多线程优化，在同步锁只有一个线程时，是不需要触发同步的，会给线程加一个偏向锁，遇到其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁
* 轻量级锁：轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁
* 可重入锁：同一个线程每进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁
* 公平锁：在获取锁之前会先判断等待队列是否为空或者自己是否位于队列头部，该条件通过才能继续获取锁
* 非公平锁：与公平锁的区别在于新获取锁的线程会有多次机会去抢占锁，但如果被加入了等待队列后则跟公平锁没有区别
* 乐观锁：认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为其他线程不会修改，写数据时先读出当前版本号，比较跟上一次的版本号，如果一样则更新，如果不一样则要重复读-比较-写的操作，通过CAS实现
* 悲观锁：认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，如Synchronized
* 在所有的锁都启用的情况下线程进入临界区时会先去获取偏向锁，如果已经存在偏向锁了，则会尝试获取轻量级锁，启用自旋锁，如果自旋也没有获取到锁，则使用重量级锁，没有获取到锁的线程阻塞挂起，直到持有锁的线程执行完同步块唤醒他们
***
### 用过哪些原子类
* AtomicInteger,原子类内部使用volatile确保可见性和有序性，使用Unsafe提供的CAS方法确保原子性
***
### 用过线程池吗，newCache 和 newFixed 有什么区别，他们的原理简单概括下，构造函数的各个参数的含义是什么，比如 coreSize，maxsize 等
* newCachedThreadPool可缓存线程池，程池中的corePoolSize就是线程池中的核心线程数量，在没有用的时候，也不会被回收，maximumPoolSize是线程池中可以容纳的最大线程的数量，而keepAliveTime，就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间
* newFixedThreadPool定长线程池，可控制线程最大并发数，超出的线程会在队列中等待
***
### 线程池的关闭方式和区别
* shutdown()，不会立即的终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务
* shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务
***
### spring 的 controller 是单例还是多例，怎么保证并发的安全
* 单例，使用ThreadLocal来保存类变量，将类变量保存在线程的变量域中，让不同的请求隔离开来
* 对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式，前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响
***
### ThreadLocal
* 通过threadlocalMap进行存储键值 每个ThreadLocal类创建一个Map，然后用线程的ID作为Map的key，实例对象作为Map的value，这样就能达到各个线程的值隔离的效果
***
### 实现并发安全的链表
* 粗粒度锁，完全锁住链表
* 细粒度锁是将锁放到node里，每次需要修改的仅仅是部分节点，而不用把整个list锁住，这样能保证不同线程可以同时处理list
***
### 无锁数据结构
* 原子性操作，可认为是一个不可分的操作，要么全部发生，要么全部不发生
* 内存访问控制方法，如CAS
***
### 多线程挂起怎么办
* sleep方法
* suspend与resume方法
***
### countdowlatch 和 cyclicbarrier 的内部原理和用法
* CountDownLatch用于同步时一个或多个线程等待其他线程的某些操作完后才继续进行
* CyclicBarrier用于若干线程需要阻塞在一个地方,够数了然后在同时进行
***
### Synchronized同步静态方法和非静态方法
* 修饰静态方法，实际上是对该类对象加锁-类锁
* 修饰非静态方法，实际上是对调用该方法的对象加锁-对象锁
* 当多线程同时访问某个被synchronized修饰的静态方法或非静态方法时，一旦某个线程抢得该类的类锁或对象锁之后，其他的线程只有排队对待
***
### ConcurrentLinkedQueue 和 LinkedBlockingQueue 的用处和不同之处
* LinkedBlockingQueue实现是线程安全的，采用锁机制，是阻塞队列，实现了先进先出等特性，是作为生产者消费者的首选
* ConcurrentLinkedQueue是并发队列的一个安全实现，元素按FIFO原则进行排序，采用CAS操作，来保证元素的一致性
***
### 致线程死锁的原因？怎么解除线程死锁
* 多个进程在运行过程中因争夺资源而照成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进
* 互斥条件、请求和保持条件、不剥夺条件和环路等待条件
* 解除：
    * 加锁顺序，线程按照一定的顺序加锁
    * 加锁时限，线程尝试获取锁的时候加上一定的时限，超过时限则放弃对锁的请求，并释放自己占有的锁
    * 死锁检测
***
### 非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案
* 此问题的本质是保持顺序执行,可以使用executors
***