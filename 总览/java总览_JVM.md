### 什么情况下会发生栈内存溢出
* 如果线程请求的栈容量超过栈允许的最大容量，会抛出StackOverflow异常
* 是否有递归调用、是否有大量循环或死循环、全局变量是否过多、数组、List、Map数据是否过大
***
### 一次完整的GC流程是怎样的，对象如何晋升到老年代，主要的JVM参数
* 大多数刚创建的对象会被分配在Eden区，当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0
* 当Survivor0也满的时候，将其中仍然活着的对象直接复制到Survivor1，以后Eden区执行Minor GC后，就将剩余的对象添加Survivor1
* 当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代）之后，仍然存活的对象将被复制到老年代
* 主要的JVM参数：
    * -XX:SurvivorRatio参数来配置Eden区域Survivor区的容量比值，默认是8
    * -XX:+UseAdaptiveSizePolicy动态调整Java堆区域的大小以及进入老年代的年龄
    * -XX:+UseParNewGC控制使用ParNew+Serial Old收集器组合收集内存
    * -XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收
***
### 几种垃圾收集器，各自的优缺点，讲一下cms
* 年轻代收集器：
    * Serial收集器：“停止-复制”算法，单线程，进行垃圾收集时必须暂停其他线程的所有工作
    * ParNew收集器：Serial收集器的多线程版本，“停止-复制”算法，多线程
    * Parallel Scavenge收集器：”停止-复制“算法，并行的多线程收集器，可控制的吞吐量
* 老年代收集器：
    * Serial Old：Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法
    * Parallel Old收集器：Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法
    * CMS收集器：CMS(Conrrurent Mark Sweep)收集器是以获取最短回收停顿时间为目标的收集器,使用"标记-清除"算法
* CMS收集器：
    * 初始标记：标记GCRoots能直接关联到的对象，时间很短
    * 并发标记：进行GCRoots Tracing（可达性分析）过程，时间很长
    * 重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长
    * 并发清除：清除未标记(无关联引用)的对象，伴随着用户线程的执行，清除后会产生浮动垃圾
    * 优缺点：对CPU资源非常敏感，可能会导致应用程序变慢，吞吐率下降，无法处理浮动垃圾，采用的“标记-清除”算法，会产生大量的内存碎片
***
### 垃圾回收算法的实现原理
* 停止-复制算法：将内存分为两块，当其中一块内存用完了，将还存活着的对象复制到另一块中，再将使用过的内存一次性清理掉
* 标记-清除算法：首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象
* 标记-整理算法：让所有存活对象都向一端移动，然后直接清理掉边界以外的内存
***
### 内存溢出排错
* 检查代码中是否有死循环或递归调用
* 检查是否有大循环重复产生新对象实体 
* 检查对数据库查询中，是否有一次获得全部数据的查询，如果一次取十万条记录到内存，就可能引起内存溢出，对于数据库查询尽量采用分页的方式查询
* 检查List和Map等集合对象是否有使用完后，未清除的问题，List和Map等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收
***
### JVM内存模型的相关知识，重排序，内存屏障，happens-before,主内存，工作内存
* 内存模型
    * 程序计数器：指向当前线程正在执行的字节码代码的行号
    * 虚拟机栈：线程私有，每个线程对应一个Java虚拟机栈，每个Java方法在被调用的时候都会创建一个栈帧，并入栈，局部变量表、操作数栈、动态链接、方法出口信息
    * 本地方法栈：本地方法栈为虚拟机使用到的native方法服务
    * 堆：几乎所有对象实例和数组都要在堆上分配，垃圾收集器的主要活动区域
    * 方法区：永久代，存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，运行时常量池-方法区的一部分，用于存放编译期生成的各种字面量和符号引用
* 重排序：对指令进行重排序，从而更适合于CPU的并行执行，不会影响单线程环境的执行结果，但是会破坏多线程的执行语义
* as-if-serial：所有的操作均可以为了优化而被重排序，但必须要保证重排序后执行的结果不能被改变，编译器、runtime、处理器都必须遵守as-if-serial语义
* happens-before:在JMM(java内存模型)，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系
    * 次序规则：一个线程内，按照代码顺序，前面的操作先行发生于后面的操作
    * 锁规则：解锁操作先行发生于后面对同一个加锁操作
    * volatile规则:对一个变量的写操作先行发生于后面对这个变量的读操作
* 主内存是所有的线程所共享的，工作内存是每个线程自己有一个，不是共享的
***
### 讲一下了解的类加载器
* 类加载：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象
* 启动（Bootstrap）类加载器：加载的是JVM自身需要的类，它负责将<JAVA_HOME>/lib核心类库或-Xbootclasspath参数指定路径下的jar包加载到内存中
* 扩展（Extension）类加载器:它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库
* 系统（System）类加载器:负责加载经常用到的classpath路径下的类库
* 双亲委派模式：类加载器收到了类加载请求，它并不会自己先加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载
***
### Java反射机制
* 概念：对于我们定义的每一个类，在任何的时刻，我们都能够知道这个类里面的属性和方法，对于任何一个对象，都能够调用这个类中的方法
* 实现功能：在运行时判断任意一个对象所属的类，在运行时构造任意一个类的对象，在运行时判断任意类所具有的方法和属性，在运行时调用任意一个对象的方法
生成动态代理
* 如何使用反射机制：反射机制里一个特点就是实例化class对象，因为任意一个类对象都是class的实例，通过forname()方法、对象.getclass()、类.class
***
### jvm参数含义
* -Xms JVM启动初始化堆大小,-Xmx JVM最大的堆大小,-Xss 每个线程的堆栈大小
* -XX:PermSize JVM持久代的初始化大小,-XX:MaxPermSize 持久代的最大大小
* -XX:MaxTenuringThreshold晋升年龄最大阈值(默认15)
* -XX:CMSInitiatingOccupancyFraction(默认值68)第一次CMS垃圾收集会在老年代被占用68%时被触发 
* -XX:+UseCMSInitiatingOccupancyOnly 用该标志来命令JVM不基于运行时收集的数据来启动CMS垃圾收集周期
***
